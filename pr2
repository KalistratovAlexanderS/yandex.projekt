# Исследование надёжности заёмщиков

Заказчик — кредитный отдел банка. Нужно разобраться, влияет ли семейное положение и количество детей клиента на факт погашения кредита в срок. Входные данные от банка — статистика о платёжеспособности клиентов.

Результаты исследования будут учтены при построении модели **кредитного скоринга** — специальной системы, которая оценивает способность потенциального заёмщика вернуть кредит банку.

## Шаг 1. Откройте файл с данными и изучите общую информацию

import pandas as pd # импорт библиотеки pandas
df = pd.read_csv('/datasets/data.csv') # чтение файла с данными
df.info()

# посмoтрим какие значения есть в таблице, чтобы оценить их реалистичность

display(df.head(10))

# проверим есть  ли пропуски  
display(df.isna().sum())

#по скольку главный вопрос крединого отдела - нужно разобраться, влияет ли семейное положение и количество детей, 
#подсчитаем уникальаные значения по столбцам children 

df['children'].value_counts()

#и family_status

df['family_status'].value_counts()

#и gender

df['gender'].value_counts()

#сразу удилим XNA значение как "артифакт"

df=df.drop(df[df['gender']=='XNA'].index)
df['gender'].value_counts()

**Вывод**

Из анализа таблицы видно, что в ряде колонках данные не заполнены(скорее всего пользователи просто подали заявку на кредит без указания данных о себе), также есть данные которые не приведены к нужному типу (вещественный вместо целых, объект вместо строки), некоторые значение которые должны быть целыми и положительными (стаж работы, доход) - записаны в виде отрицательного числа. Есть не присущий значения - артефакты. Данные в столбце с кол-вом детей не корректны (сильно завышены и отрицательные)

## Шаг 2. Предобработка данных

### Обработка пропусков

#Доля пропусков по следующим колонкам days_employed и total_income одинакова
#возможные причины появления пропусков - технические проблемы при выгрузке
#  пропуски заменяем средним значением 

df['days_employed'] = df['days_employed'].mean()
display(df.tail(10))

#данные по столбцу total_income важны для дальнейшего анализа, поэтому заменим пропущенные зачения медианой

#добавим комментарии чтобы проверить  группы с НаН

#total_income_median = df['total_income'].median()
#df['total_income'] = df['total_income'].fillna(total_income_median)

#
df['total_income'].value_counts()
#display(df[15100:15120])
unique_income_type = list(set(df['income_type']))
display(unique_income_type)

# КОД РЕВЬЮЕРА
df.pivot_table(index='income_type', columns='education', values='total_income', aggfunc='median')

# КОД РЕВЬЮЕРА

# То же самое.
df.groupby(['income_type', 'education']).agg({'total_income':'median'})

# КОД РЕВЬЮЕРА

qq = df.pivot_table(index=['income_type', 'gender'], columns='education', values='total_income', aggfunc='median')
qq.loc[('студент', 'M')]['высшее']

#посмтрим срез с зачаеним NaN
display(df[15109:15111])

#проведем группировку 
df['total_income'] = df['total_income'].fillna(df.groupby('income_type')['total_income'].transform('median'))

#посмтрим срез как отработат transform строки с заменой 
display(df[15109:15111])

# проверим все  ли пропуски  заменены

print(df.isna().sum())

# и посмотрим как теперь выглядт таблица с данными

display(df.head(10))

#Проверим столбец children на реалистичность данных

df['children'].value_counts()

#В столбце есть отрицальное значения -1, скорее всего это опечатка в при вводе - заменим их на положильные
df['children']=df['children'].replace(-1,1)

#также кол-во детей 20 - заменим на 2, как ошибка при вводе
df['children']=df['children'].replace(20,2)

#Проверим как выклядит столбец children 
df['children'].value_counts()

#Проверим столбец dob_years.

df['dob_years'].value_counts().head(50)

#видим, что есть клиенты с "нулевым" возрастом

#чтобы не потерять данные о клинетах для которых по какой-то причине возраст указан "0", 
#заменим значения в этой ячейке на среднее, так как отдел банка не просит точного срезы по возрастной группе заемщиком, 
#этот метод будет допустимым

df['dob_years']=df['dob_years'].replace(0,df['dob_years'].mean())

df['dob_years'].value_counts().head(15)

**Вывод**

пропущенные данные по нужным в дальнешим строкам удалены - с данными можно проводить анализ.

### Замена типа данных

#заменим данные на целые по нужным в дальнешем  анализе столбцам days_employed и  total_incom и dob_years
df['days_employed'] = df['days_employed'].astype('int')
df['total_income'] = df['total_income'].astype('int')
df['dob_years'] = df['dob_years'].astype('int')
df['purpose'] = df['purpose'].astype('str')

df['family_status'] = df['family_status'].astype('str')

# проверим все ли типы данных заменили
df.info()

**Вывод**

нужные в дальнейшим для принятие решения по выдаче кредита данные обработаны, тип данных изменен

### Обработка дубликатов

#при изучении общей информации о данных видно, что по столбы education есть дубликаты, посмотрим их

display(df['education'].value_counts())


#приведем к нижнему регистру данные столбца education тем самы заменим дубликаты

df['education'] = df['education'].str.lower()
display(df['education'].value_counts())

#Теперь установим наличие полных дубликатов (ошибочный ввод опретором одних и тех данных, техническая ошибка при записи данных
# в базу данных о вадаче кредита) 

df.duplicated().sum()

#и избавимся от них, чтобы данные по анализы были макимально корректными

df = df.drop_duplicates().reset_index(drop=True)
df.duplicated().sum()

**Вывод**

Дубликаты в данных могли появиться в результате сбоев при записи значений в базу данных. Дубликаты в столбце education появилась в результате человеческого фактора (скорее всего у менеджера, который принимал заявку на кредит и заполнял данные клиента не было точных инструкций как заполнять данное поле (с большой буквы, все маленькие, полное/сокращённое). При помощи  value_counts() я получил все значение, а при помощи str.lower привел их к одному регистру, а после удалил полные дубликаты используя метод drop_duplicates(), чтолбы анализ был максимально корректным.

### Лемматизация

#посмотрим какие уникльные значения клиенты указывают в качестве причины для выдачи кредита, посчитаем их кол-во

df['purpose'].value_counts()

#Лемматизируем значения столбца purpose с помощью библиотеки pymystem3, 
#а после добавим новый столбец purpose_category с категориями целей в запросе на кредит

from pymystem3 import Mystem
m = Mystem()

def find_category(row):
    lemmas = m.lemmatize(row)
    if 'автомобиль' in lemmas:
        return 'автомобиль'
    elif 'свадьба' in lemmas:
        return 'свадьба'
    elif 'образование' in lemmas:
        return 'образование'
    elif ('недвижимость' in lemmas) or ('жилье' in lemmas):
        return 'недвижимость'
    else:
        return 'другая категория'



#Применяем созданную функцию к колонке loan_purpose и добавляем колонку с леммами - loan_purpose_dict

df['purpose_category'] = df['purpose'].apply(find_category)
display(df.head(10))

#поcмoтрим как получилась разделение на категории тв ыводим перечень целей получения кредита, отсортированный по убыванию

purpose_category=df.groupby('purpose_category')['purpose_category'].count()
display(purpose_category.sort_values(ascending = False))

**Вывод**

Видно, что в качестве причины к выдачи кредита клиенты  указывают такие основы причины: 1) покупка автомобиля  2) организация свадьбы  3)получение образования 4) деньги на недвижимости(как покупка так и строильство и ремонт) . Для удобства анализа причины к выдаче/отказ к выдаче -  я выделил эти причины в отдельные группу при помощи функции. Метод лемматизации показал,  что более половины клиентов берут кредит на приобретение недвижимости.

### Категоризация данных

Поскольку ранее я уже выделил категорию заёмщиков по цели кредита, сделаю сейчас категории  в зависимости от дохода
Для этого напишем функцию, которая выделит клиентов в зависимости от дохода.В начале посмотрим какое есть максимальное и минимальное  значение дохода

#макимальное и минимальное значние в столбце 'total_income

display(df[df['total_income'] == df['total_income'].max()]) 
display(df[df['total_income'] == df['total_income'].min()]) 

# теперь напишем функцию, которая выделит клинетов в зависимоти от дохода, опредлим 4 категории 
#низкий как двойная(3*) величина самого минимального дохода, средний как патикратная(6*) величина, выкокий как почти что макимальная но мнешьше       
          
def total_income_group(income):
    if income<120000:
        return 'низкий доход'
    if 40001<=income<200000:
        return 'средний доход'
    if 100001<=income<300000:
        return 'высокий доход'
    return 'очень высокий доход'
           


df['total_income_category'] = df['total_income'].apply(total_income_group)


display(df.head(10))



df['total_income_category'].value_counts()

**Вывод**

Выделил категорию заемщиком в зависимости от уровня дохода, эти категории пригодятся  при анализе возврата кредита в зависимости от уровня дохода заемщика

## Шаг 3. Ответьте на вопросы

- Есть ли зависимость между наличием детей и возвратом кредита в срок?

#определим как кол-во детей влияет на возврат кредита в срок, для этого найдем 
#отношение кол-во заемщиков с детьми к возврату кредита и выведем данные в процентах c округлением

debt_from_children = pd.DataFrame()
debt_from_children['count_children'] = df.groupby('children')['debt'].count()
debt_from_children['sum_children'] = df.groupby('children')['debt'].sum()
debt_from_children['result_children'] = round((debt_from_children['sum_children'] / debt_from_children['count_children'])*100,2)

#и отсортируем результат по возрастанию кол-во просроченных кредитов
display(debt_from_children.sort_values(by = 'sum_children', ascending = False))

# КОД РЕВЬЮЕРА 

df.groupby('children')['debt'].agg(['count','sum','mean'])

# КОД РЕВЬЮЕРА

def my_mean(x): return x.mean()*100

# В кач-ве агрегирования можно любую функцию брать.
df.groupby('children')['debt'].agg(['count', 'sum', my_mean])

# КОД РЕВЬЮЕРА

def my_mean(x): return x.mean()*100

df.groupby('children')['debt'].agg(['count', 'sum', my_mean])

# КОД РЕВЬЮЕРА


def my_mean(x): return '{:.2%} '.format(x.mean())

df.groupby('children')['debt'].agg(['count', 'sum', my_mean])

**Вывод**

Таким образом,  несмотря на максимальное количество клиентов с просроченными кредитами у которых нет детей, доля их в сравнении с иными категориями клиентов меньшая чуть больше 9%,  а доля просроченных кредитов у клиентов имеющих от 1 до 4 детей - составила от 8-10 %  В силу малого количества попавших в выборку клиентов с 5-ю детьми, резульат по ним можно не учитывать.

- Есть ли зависимость между семейным положением и возвратом кредита в срок?



# str - чтобы добавить %
df.groupby('children')['debt'].agg(['count', 'sum', lambda x: str(round(x.mean()*100,2)) +'%' ])

#определим зависимость между семейным положением и возвратом кредита в срок при помощи агрегирования 

def ff_family_status(x): return '{:.2%} '.format(x.mean())

df.groupby('family_status')['debt'].agg(['count', 'sum', ff_family_status])


**Вывод**

Есть опредленная зависимость. Люди не в браке и не бывавшие в браке имеют больший процент невозвратов в срок. Но, те кто развелись или овдовели чаще платят в срок, чем люди в браке.

- Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

import numpy as np #импорт библиотеки numpy

#С помощью конструктора DataFrame создадим таблицу total_income_debt 
total_income_debt=pd.DataFrame(df, columns=['total_income', 'debt']) 

#в качестве диапазона дохода возьмем уровень дохода расчитанный ранее 
total_income_debt['income_groups'] = (
           pd.cut(total_income_debt['total_income'], [0,120000,200000,300000,np.inf],labels=
           ['низкий доход', 'средний доход', 'высокий доход', 'очень высокий доход']))
total_income_debt=total_income_debt.groupby('income_groups')['debt'].agg(['count','sum'])
total_income_debt['%']=round((total_income_debt[('sum')]/total_income_debt[('count')])*100,2)
#и отсортируем результат по возрастанию процента кол-во просроченных возрататов
total_income_debt.sort_values(['%'], ascending = False)
#total_income_debt

**Вывод**

Зависимости между уровнем дохода и наличием просроченной задолженности не наблюдается так как нет резких колебаний процента невозврата кредита (число заемщиков, которые просрочили возврат кредита лежит  в диапазоне от 7,1 % до 8,6 %, из чего можно сделать вывод, что уровень дохода не влияет на срок возврата кредита

- Как разные цели кредита влияют на его возврат в срок?

#Как разные цели кредита влияют на его возврат в срок
debt_from_purpose_category = pd.DataFrame()
debt_from_purpose_category['sum_purpose_category'] = df.groupby('purpose_category')['debt'].sum()
debt_from_purpose_category['count_purpose_category'] = df.groupby('purpose_category')['debt'].count()
debt_from_purpose_category['result_purpose_category'] = round((debt_from_purpose_category['sum_purpose_category'] / debt_from_purpose_category['count_purpose_category'])*100,2) 

#и отсортируем результат по возрастанию кол-во просроченных кредитов
debt_from_purpose_category.sort_values('result_purpose_category', ascending = False)

**Вывод**

Среди наших отобранных категорий, чаще всего платят в срок с целью кредита недвижимость, чаще просрочка у тех кому нужен кредит на свадьбу. Риск не воврата кредита на автомобиль или образвание примерно одинаковый 

## Шаг 4. Общий вывод

Семейный статус влияет на вероятность платежей по кредиту в срок - люди, бывший в браке чаще платят в срок чем те, кто не бывали в браке, причем разведенные и овдовевшие платят в срок чаще, чем люди в браке. Чем больше детей, тем чаще платят не в срок, бездетные же реже просрочивают оплату. Уровень дохода при этом не влияет на процент просрочки по кредиту. А  кредит, цель которого  обозначена клиентом как "недвижимость" чаще всего выплачивается в срок, при этом при выдачи  кредит "на свадьбу"  советую дополнительно  проверять заемщики или использовать обеспечения погашения вторым заемщиком или находящиеся в его собственности недвижимости.

#создаем сводную таблицу и посмотрим какой максимальный процент выплат в зависимости от цели кредита
pivot_table_purpose_category = df.pivot_table(index='purpose_category', columns= 'debt', values='days_employed', aggfunc='count')
pivot_table_purpose_category['percent'] = (pivot_table_purpose_category[1]/(pivot_table_purpose_category[1] + pivot_table_purpose_category[0])) * 100

pivot_table_purpose_category.sort_values(['percent'], ascending = False)

#создаем сводную таблицу и посмотрим какой максимальный процент выплат в зависимости от кол-во детей
pivot_table_children_category = df.pivot_table(index='children', columns= 'debt', values='days_employed', aggfunc='count')
pivot_table_children_category['percent'] = (pivot_table_children_category[1]/(pivot_table_children_category[1] + pivot_table_children_category[0]) * 100)

pivot_table_children_category.sort_values(['percent'], ascending = False)
